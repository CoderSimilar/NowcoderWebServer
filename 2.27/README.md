# 程序和进程
* 进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元
* 可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构的信息包括许多与进程相关的标识号（IDs）、虚拟内存表，打开文件的描述符表，信号传递以及处理的有关信息，进程资源使用及限制、当前工作目录和大量的其他信息。

# 单道、多道程序设计
* 单道程序：在计算机内存中只允许一个的程序运行。
* 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使他们在管理程序控制下，相互穿插运行，两个或两个以上的程序在计算机系统中同处于开始到结束之间的状态，这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高CPU的资源利用率
* 对于一个单CPU系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU上运行的程序只有一个。
* 在多道程序设计模型种，多个进程轮流使用CPU。而当下常见CPU为纳秒级，１秒钟可以执行大概１０亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。
  
# 时间片
* 时间片(timeslice):又称为"量子(quantum)"或者"处理器片(processor slice)".是操作系统分配给每个正在运行的进程微观上的一段CPU时间．事实上，虽然一台计算机通常可能有多个CPU,但是同一个CPU永远不可能真正地同时运行多个任务.在只考虑一个CPU的情况下　，这些进程"看起来像"同时运行的,实际上是轮番穿插着运行.由于时间片通常很短,(在Linux上为5ms ~ 800ms),用户不会感觉到.
* 时间片由操作系统内核的调度程序分配给每个进程.首先,内核会给每个进程分配初始时间片,然后每个进程轮番地执行响应的时间,当所有进程都处于时间片耗尽的状态时,内核会重新为每个进程计算并分配时间片,如此往复.

# 并行和并发
* 并行(parallel):指在同一时刻,有多条指令在多个处理器上同时执行.
* 并发(concurrency):指在同一时刻只能有一条指令执行,但多个进程指令被快速的轮换执行,使得在宏观上具有多个进程同时执行地效果,但在微观上并不是同时执行的,只是把时间分成若干段,使得多个进程快速交替的执行
* 例子: 并发是两个队列交替使用一台咖啡机; 并行是两个队列同时使用两台咖啡机.

# 进程控制块(PCB)
* 为了管理进程,内核必须对每个进程所做的事情进行清楚的描述.内核为每个进程分配一个`PCB`(Processing Control Block)进程控制块,维护进程相关信息.`Linux`内核的进程控制块是`task_struct`结构体.
* 在`usr/src/linux-headers-xxx/include/linux/sched.h`文件中可以查看`task_struct`结构体定义,其内部成员很多,只需要掌握以下部分:
    * 进程id:系统每个进程都有唯一的`id`,用`pid_t`类型表示,其实就是一个非负整数
    * 进程的状态:就绪,运行,挂起,停止
    * 进程切换时需要保存和恢复的一些CPU寄存器
    * 描述虚拟地址空间的信息
    * 描述控制终端的信息
    * 当前工作目录
    * umask掩码
    * 文件描述符表,包含很多指向`file`结构体的指针
    * 和信号相关的信息
    * 用户id和组id
    * 会话(Session)和进程组
    * 进程可以使用的资源上限(使用命令`ulimit -a` 可以查看资源上限)

# 进程状态转换(面试常问)

* 进程状态反映进程执行过程的变化,这些状态随着进程的执行和外界条件的变化而转换.在三态模型种,进程状态分为三个基本状态:就绪态,运行态,阻塞态.在五态模型中,进程分为新建态,就绪态,运行态,阻塞态,终止态.

## 三态模型

* 运行态:进程占有处理器正在运行
* 就绪态:进程具备运行条件,等待系统分配处理器以便运行.当进程已经分配到除CPU以外的所有必要资源后,只要再获得CPU就可以立即执行.在一个系统中处于就绪态的进程可能有多个,通常将它们排成一个队列,成为就绪队列.
* 阻塞态:又称为等待态(wait)或者睡眠态(sleep),指进程不具备运行条件,正在等待某个事件的完成.

## 五态模型
* 新建态:进程刚被创建时的状态,尚未进入就绪队列
* 终止态:进程完成任务达到正常结束点,或出现无法克服的错误而异常终止,或被操作系统及有终止权的进程所终止时所处的状态,进入终止态的进程以后不再执行,但依然会保留在操作系统中等待善后.一旦其他进程完成了对终止态进程的信息抽取后,操作系统将删除该进程.

## 查看进程
`ps aux /ajx`
a : 显示终端上的所有进程,包括其他用户的进程
u : 显示进程的详细信息
x : 显示没有控制终端的进程
j : 列出与作业控制相关的信息

STAT参数表示含义:
    D   不可中断
    R   正在运行或在队列中的进程
    S   处在休眠状态
    T   停止或者被追踪
    Z   僵尸进程
    X   死掉的进程
    <   高优先级
    N   低优先级
    s   包含子进程
    +   位于前台的进程组

`top`实时查看进程状态
可以在`top`命令是加上`-d `指定显示更新的时间间隔,`top`命令执行后,可以按以下按键对显示结果进行排序:
    * M     根据内存使用量排序
    * P     根据CPU占有率排序
    * T     根据进程运行时间长短排序
    * U     根据用户名来筛选进程
    * K     输入指定的PID杀死进程

`kill`命令可杀死进程
    kill [-signal] pid
    kill -l 列出所有信号
    kill -SIGKILL 进程ID
    kill -9 进程ID

    killall naame 根据进程名杀死进程

# 进程号和相关函数
* 每个进程都由进程号来标识,其类型为pid_t(整型),进程号的范围:0 ~ 32767;进程号总是唯一的,但是可以重复使用,.当一个进程终止后,其进程号就可以再次使用
* 任何进程(除init进程)都是由另一个进程创建,该进程成为被创建进程的父进程,对应的进程号称为父进程号(PPID).
* 进程组是一个或者多个进程的集合,他们之间互相关联,进程组会接收同一终端的各种信号,关联的进程有一个进程组号(PGID).默认情况下,当前的进程号会当作当前的进程组号
* 进程号和进程组相关函数:
    * pid_t getpid(void);
    * pid_t getppid(void);
    * pid_t getpgid(pid_t pid);
  
# 创建进程
系统允许一个进程创建新进程,新进程即为子进程,子进程还可以创建新的子进程,形成进程树结构模型
