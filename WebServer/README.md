# 两种高效的事件处理模式

服务器程序通常需要处理三类事件：I/O 事件、信号及定时事件。有两种高效的事件处理模式：Reactor 和 Proactor，同步 I/O 模型通常用于实现 Reactor 模式，异步 I/O 模型通常用于实现 Proactor 模式。

## Reactor模式

要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

使用同步I/O（以epoll_wait为例）实现的Reactor模式的工作流程是：

    1,主线程往epoll内核事件表中注册socket上的读就绪事件。
    2,主线程调用epoll_Wait等待socket上有数据可读。
    3,当socket上有数据可读时，epoll_wait通知主线程，主线程则将socket刻度时间放入请求队列。
    4,睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll_内核事件表中注册该socket上的写就绪事件。
    5,当主线程调用epoll_wait等待socket可写。
    6,当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。
    7,睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。

## Proactor模式

Proactor模式将所有I/O操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻辑。使用异步I/O模型（以aio_read和aio_write为例）实现的Procate模式的工作流程是：

    1,主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）。
    2,主线程继续处理其他逻辑。
    3,当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据数据已经可用。
    4,应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。
    5,主线程继续处理其他逻辑。
    6,当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。
    7,应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。

## 模拟Procactor模式

使用同步I/O方式模拟出Proactor模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的就是对读写的结果进行逻辑处理。

使用同步I/O模型（以epoll_wait为例）模拟出的Procator模式的工作流程如下：

    1,主线程往epoll内核事件表中注册socket上的读就绪事件。
    2,主线程调用epoll_wait等待socket上有数据可读。
    3,当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。
    4,睡眠在请求队列上的某个工作线程被唤醒,它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。
    5,主线程调用epoll_wait等待socket可写。
    6,当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。

## EPOLLONESHOT事件

即使可以使用ET模式，一个 socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如个线程在读取完某个 socket 上的数据后开始处理这些教据，而在教据的处理过程中该 socket 上又有新数据可读(EPOLLIN 再次被触发)，此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。

对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件目只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注的 EPOLLONESHOT 事件。这样，当一个结程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的，但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕，该线程就应该立即重置这个 socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket.

    
