# 共享内存
共享内存是效率最高的一种进程间通信的方式，因为其直接操作内存。
* 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会被称为一个进程用户空间的一部分，因此这种IPC机制无需内核介入。所有需要做的就是让一个进程将数据复制到共享内存中，并且这部分数据会对其他所有共享一个段的进程可用。
* 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种IPC技术的速度更快。

# 共享内存使用步骤
* 调用`shmget()`创建一个新的共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。
* 使用`shmget()`来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。
* 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为了引用这块共享内存，程序需要使用由`shmat()`调用返回的addr值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。
* 调用`shmdt()`来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且再进程终止时会自动完成这一步。
* 调用`shmctl()`来删除共享内存段。只有当目前所有附加内存段的进程都与之分离之后，内存段才会销毁。只有一个进程需要执行这一步。

# 共享内存操作函数

#include<sys/ipc.h>
#include<sys/shm.h>

* int shmget(key_t key, size_t size, int shmflg);
    - 功能：创建一个新的共享内存段，或者获取一个新的共享内存段的标识。新创建的内存段中的数据都会被初始化为0.
    - 参数：
      - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。一般用16进制表示，非0值。
      - size : 共享内存的大小。
      - shmflg : 共享内存的属性：
        - 访问权限
        - 附加属性：创建/判断共享内存是不是存在。
          - 创建：IPC_CREAT
          - 判断共享内存是否存在：IPC_EXCL，需要和IPC_CREAT一起使用
          - IPC_CREAT | IPC_EXCL | 0664
    - 返回值：
      - 失败返回-1，并设置错误号
      - 成功返回大于0的一个值，表示共享内存的一个引用的id，后面操作共享内存都要用到这个值。


* void *shmat(int shmid, const void *shmaddr, int shmflg);
    - 功能：和当前的进程进行关联。
    - 参数：
      - shmid : 共享内存的标识（ID），由shmget返回值获取
      - shmaddr : 申请的共享内存的起始地址，指定NULL表示由内核指定。
      - shmflg : 对共享内存的操作
        - 读权限：SHM_RDONLY，必须要有读权限
        - 读写权限：0
    - 返回值：
      - 成功返回共享内存的首（起始地址）
      - 失败返回(void*)-1，并设置错误号


* int shmdt(const void *shmaddr);
    - 功能：解除当前进程和共享内存的关联
    - 参数：
      - shmaddr : 申请的共享内存的起始地址，指定NULL表示由内核指定。
    - 返回值：
      - 成功返回0
      - 失败返回-1，并设置错误号


* int shmctl(int shmid, int cmd, struct shmid_ds *buf);
    - 功能：删除共享内存，共享内存要删除才会消失，创建共享内存的进程被销毁了对共享内存没有影响。
    - 参数：
      - shmid : 共享内存的id
      - cmd : 对共享内存要做的操作：
        - IPC_STAT : 获取共享内存当前的状态
        - IPC_SET : 设置共享内存的状态
        - IPC_RMID : 标记共享内存被销毁
      - buf : 需要设置或者获取的共享内存属性信息
        - IPC_STAT : buf存储数据
        - IPC_SET : buf中需要初始化数据，设置到内核中
        - IPC_RMID : 没有用，NULL


* key_t ftok(const char* pathname, int proj_id);
    - 功能：根据指定的路径值和int值，生成一个共享内存的key
    - 参数：
      - pathname : 指定一个存在的路径（例如：/home/admin/cppCode）
      - proj_id : int类型的值，但是这个系统调用只会使用其中的1个字节

# 总结

* 1，操作系统如何知道一块共享内存被多少个进程关联？
  - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员shm_nattch，shm_nattch 记录了关联的进程个数。
## 常用的ipcs命令
**ipcs 用法**

ipcs -a  // 打印当前系统中所有的进程间通信方式的信息
ipcs -m  // 打印出使用共享内存进行进程间通信的信息
ipcs -q  // 打印出使用消息队列进行进程间通信的信息
ipcs -s  // 打印出使用信号进行进程间通信的信息

**ipcrm用法**

ipcrm -M shmkey // 移除用shmkey创建的共享内存段
ipcrm -m shmid  // 移除用shmid标识的共享内存段
ipcrm -Q msgkey // 移除用msqkey创建的消息队列
ipcrm -q msqid  // 移除用msqid标识的消息队列
ipcrm -S semkey // 移除用semkey创建的信号
ipcrm -s semid  // 移除用semid标识的信号

* 2，可不可以对共享内存进行多次删除 shmctl
  - 可以的
  - 因为shmctl标记删除共享内存，不是直接删除
  - 什么时候真正删除？
      当和共享内存关联的进程数为0的时候，就被真正删除
  - 当共享内存的key为0的时候，表示共享内存被标记删除了
      如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存，也不能再次进行关联。

* 3，共享内存和内存映射的区别
  - 1，共享内存可以直接创建，内存映射需瓷盘文件。（匿名映射除外）
  - 2，共享内存效率更高
  - 3，内存：
    - 所有的进程操作同一块共享内存； 
    - 内存映射，所有的进程在自己的虚拟地址空间中有一个独立的内存。
  - 4，进程突然退出：
    - 共享内存还存在；
    - 内存映射区消失。
  - 5，运行进程的电脑死机，宕机了：
    - 数据存在共享内存中，没有了；
    - 内存映射区的数据，由于磁盘文件中的数据还存在，所以内存映射区还存在。
  - 6，生命周期：
    - 内存映射区：进程退出，内存映射区销毁。
    - 共享内存：进程退出，共享内存还在，标记删除(所有的关联的进程数为0)，或者关机。如果一个进程退出，会自动和共享内存进行取消关联。


# 守护进程

## 终端

* 在UNIX系统中，用户通过终端登录系统后得到一个 `shell` 进程，这个终端成为 `shell` 进程的控制终端 (Controlling Terminal)。进程中，控制终端是保存在 PCB 中的信息，而 `fork()` 会复制 PCB 中的信息，因此由 `shell` 进程启动的其它进程的控制终端也是这个终端。
* 默认情况下(没有重定向)，每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。
* 在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 `ctrl + C`会产生 `SIGINT` 信号，`ctrl + \`  会产生 `SIGQUIT` 信号。

输入`echo $$`命令可以查看当前控制终端的进程id，输入`tty`可以查看当前终端所在目录。

## 进程组

* 进程组和会话在进程之间形成了一种两级层次关系:进程组是一组相关进程的集合会话是一组相关进程组的集合。进程组合会话是为支持 shell 作业控制而定义的抽象概念，用户通过 she11 能够交互式地在前台或后台运行命令。
* 进行组由一个或多个共享同一进程组标识符 (PGID) 的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。
* 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个1430求Q进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。

## 会话

* 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。
* 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。
* 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。
* 当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。

## 进程组、会话操作函数

* pid_t getpgrp(void);
* pid_t getpgid(pid_t pid);
* int setpgid(pid_t pidm pid_t pgid);
* pid_t getsid(pid_t pid);
* pid_t setsid(void);

## 守护进程

* 守护进程 (Daemon Process)也就是通常说的 Daemon 进程 (精灵进程)，是inux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。
* 守护进程具备下列特诊:
  * 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。
  * 它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号(如 SIGINT、SIGQUIT)。
* Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetdWeb 服务器 httpd 等。

### 守护进程创建的步骤

* 执行一个`fork()`，之后父进程退出（父进程如果不退出的话，继续执行直到父进程结束，终端会显示提示符），子进程继续执行。
* 子进程调用`setsid()`开启一个新会话。（子进程不是当前进程组的组长，因此可以调用`setsid()`从而开启一个新的会话。因为子进程创建新的会话组不会与原会话组产生冲突。）
* 清除进程的 `umask` 以确保当守护进程创建文件和目录时拥有所需的权限。
* 修改进程的当前工作目录，通常会修改为根目录（/）。
* 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。
* 在关闭了文件描述符0，1，2之后，守护进程通常会打开/dev/null，并使用dup2()使所有的这些描述符指向这个设备。
* 核心业务逻辑

