# 有名管道

* 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。 匿名管道说白了就是内核中实现的一块内存空间，在亲缘关系的进程之间创建时可以继承父进程的内核地址空间信息，从而可以实现在亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道，FIFO文件
* 有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，并且其打开方式和打开一个普通文件是一样的，这样即使与FIFO的创建进程不存在亲缘关系的进程，只要看可以访问到该路径，就能够彼此通过FIFO相互通信。因此，与FIFO不相关的进程也能够交换数据。
有亲缘关系的进程也可以通过有名管道来传递信息
* 一旦打开了FIFO，就能在它上面使用与操作者匿名管道和其他文件的系统调用一样的I/O系统调用了（如read(),write(),和close()），和管道一样，FIFO也有一个写入端和一个读取端，并且从管道中读取和写入的顺序是一样的，FIFO的名称也由此而来：先入先出。
* 有名管道的数据结构也是一个环形队列
* 有名管道（FIFO）和匿名管道（pipe）有一些特点是相同的，不一样的地方在于：
    * FIFO在文件系统中作为一个特殊文件存在，而匿名管道是没有文件的。FIFO文件中没有内容，内容存放在内存中
    * 当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。
    * FIFO有名字，不相关的进程可以通过打开有名管道进行通信。

# 有名管道的使用

* 通过命令创建有名管道：
  * mkfifo 名字
* 通过函数创建有名管道
  * #include<sys/types.h>
  * #include<sys/stat.h>
  * int mkfifo(const char *pathname, mode_t mode);
* 一旦使用mkfifo创建了一个FIFO，就可以使用`open()`打开它，常见的I/O函数都可以用于fifo。如：`close`,`read`,`write`,`unlink`等。
* FIFO严格遵循先进先出（First in First out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾，它们不支持诸如`lseek()`等文件定位操作。

# 有名管道的注意事项

* 一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道
* 一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道

* 读管道：
    * 管道中有数据：
        * read返回实际读到的字节数
    * 管道中无数据：
        * 管道写端被全部关闭，read返回0（相当于读到文件末尾）
        * 写端没有全部被关闭，read阻塞等待
* 写管道：
    * 管道读端被全部关系，进程异常终止（收到一个SIGPIPE信号）
    * 管道读端没有全部关闭：
        * 管道已经满了，write会阻塞
        * 管道没有满，write将数据写入，并返回实际写入的字节数。

无论是匿名管道还是有名管道，操作的都是内核的一块缓冲区。

# 使用有名管道完成简单聊天功能

创建两个管道，分别用于两个进程间的通信。
* 进程A：
    * 1，以只写的方式打开管道1
    * 2，以只读的方式打开管道2
    * 3，循环的写读数据：
        * while(1) {
            //获取键盘录入fgets(不能使用scanf，因为遇到换行就停止了)
            写管道1
            读管道2
        }
* 进程B：
    * 1，以只读的方式打开管道1
    * 2，以只写的方式打开管道2
    * 3，循环的读写数据：
        * while(1) {
            读管道1
            //获取键盘录入fgets(不能使用scanf，因为遇到换行就停止了)
            写管道2
        }