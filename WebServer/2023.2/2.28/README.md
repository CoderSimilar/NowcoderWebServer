
fork函数创建子进程后，子进程和父进程运行在不同的进程地址空间。但是在fork函数刚执行完后，子进程与父进程的进程地址空间相同。
实际上，更准确来说，Linux的 `fork()` 是通过写时拷贝（copy-on-write）技术实现的。
写时拷贝是一种可以推迟甚至避免拷贝数据的技术。
内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只有在需要写入的时候才会复制地址空间，从而使各个进程拥有各自的地址空间。
也就是说 ，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享的
注意：`fork`之后父子进程共享文件
`fork`产生的子进程与父进程相同的文件描述符指向相同的文件表，文件的引用计数增加，共享文件偏移指针。

**读时共享，写时复制**


父子进程之间的关系：
    区别：
        1，fork()函数的返回值不同
            父进程：>0 返回子进程的ID
            子进程：=0
        2，pcb中的一些数据
            当前进程的id， pid
            当前进程的父进程的id，ppid
    共同点：
        某些状态下，子进程刚被创建出来，还未执行任何写数据的操作。
            - 用户区的数据
            - 文件描述符表 

    父子进程对变量是不是共享的？
        - 刚开始的时候是一样的，共享的。如果修改了数据，就不共享了。
        - 读时共享（子进程被创建，未进行任何写的操作），写时复制
        - 

GDB多进程调试

使用GDB调试的时候，GDB默认只能跟踪一个进程，可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者跟踪子进程，默认跟踪父进程。

设置调试父进程或者子进程：
    `set follow-fork-mode [parent(默认) | child]`

设置调试模式：
    `set detach-on-fork [on | off]`
    默认为on，表示调试当前进程的时候，其他的进程继续运行，如果为off的时候，其他进程被GDB挂起

查看调试的进程：info inferiors
切换当前调试的进程 ：inferior id
使进程脱离GDB调试：detach inferiors id

# exec函数族
函数族：一系列功能相同或者相似的函数，类似于C++的函数重载

* exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件
* exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍然保持原样。有些类似于“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，去已经注入了新的灵魂。只有调用失败了，才会返回-1，从原程序的调用点接着往下执行。
* 先创建一个子进程，在子进程里执行exec函数族

调用exec函数族并不会创建新的进程，exec函数会将指定运行的函数的用户区的数据替换原进程地址空间中用户区的数据，保留原进程的内核区。进程开始从指定运行程序的main函数开始执行。

**exec函数族**

标准C库函数：
    int execl(const char *path, const char *arg, .../* (char *) NULL * /);
    int execlp(const char *file, const char *arg, .../* (char *) NULL */);

    l






