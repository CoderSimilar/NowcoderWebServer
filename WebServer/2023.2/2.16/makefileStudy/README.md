# 动态库的制作和使用

## 命名规则：

* Linux：**libxxx.so**
    lib : 前缀（固定）
    xxx : 库名（自己起）
    .so : 后缀（固定）
**动态库在Linux下是一个可执行文件**

* Windows：**libxxx.dll**

## 动态库制作：

* `gcc`得到`.o`文件，得到和位置无关的代码。（加参数`-fPIC`）
    `gcc -c -fpic/-fPIC *.c`

* `gcc`得到动态库
    `gcc -shared *.o -o libxxx.so`

**这样制作的动态库不能使用，因为在程序运行时动态库没有加载到内存中**

## 工作原理

* 静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中
* 动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中

* 程序启动之后，动态库会被动态加载到内存中，通过`ldd`(list ayname dependencies)命令可以检查动态库的依赖关系

**如何定位共享库文件？**

当系统加载可执行代码的时候，能够知道其所依赖库的名字，但是还需要知道绝对路径。
此时就需要系统的**动态载入器**来获取该绝对路径。对于`elf`格式的可执行程序，是由`ld-linux.so`来完成的
它先后搜索elf文件的 **DT_RPATH段** ——> **环境变量LD_LIBRARY_PATH** ——> **/etc/ld.so.cache文件列表** ——> **/lib/,/usr/lib** 目录找到库文件后将其载入内存。

### 修改环境变量

`env`查看环境变量，环境变量通常以键值对的方式出现。

使用`export 环境变量=$环境变量:动态库地址` 可以修改环境变量，`$`表示获取原环境变量的值，`:`代表在原环境变量值的后面添加内容。
例如：`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/admin/cppCode/2.16/library`
**在命令行输入这条命令，则修改环境变量的操作只在当前终端生效；**

## 用户级别修改环境变量：

要在**用户级别**修改环境变量，需要进入家目录`cd ~`,输入`ll`即可看到`.bashrc`文件。使用vim将其打开，`shift+g`定位至最后一行。添加`export 环境变量=$环境变量:动态库地址`,保存退出。并使用`. .bashrc`或者`source .bashrc`命令进行刷新即可。

## 系统级别配置环境变量：

要在**系统级别**配置环境变量，需要使用`sudo vim /etc/profile`进入系统文件，然后添加`export 环境变量=$环境变量:动态库地址`到最后一行，保存退出并使用`. /etc/profile`或者`source /etc/profile`刷新即可

## 修改/etc/ld.so.cache文件

/etc/ld.so.cache中是二进制文件，不能使用vim进行编辑，但是可以通过`sudo vim /etc/ld.so.conf`命令打开`/etc/ld.so.conf` 文件，在里面添加**动态库路径**，保存退出后输入`sudo ldconfig`进行更新即可。

## 将动态库放置在`/lib`目录下

不建议使用这种方式，因为`/lib`，`usr/lib`目录下存在其他文件，容易误操作。

# 静态库和动态库的对比

**静态库优缺点**

* 优点：
    静态库被打包到应用程序中加载速度快
    发布程序无需提供静态库，移植方便

* 缺点：
    消耗系统资源
    更新、部署、发布麻烦

**动态库优缺点：**

* 优点：
    可以实现进程间资源共享（共享库）
    更新、部署、发布简单
    可以控制何时加载动态库

* 缺点：
    加载速度比静态库慢
    发布程序时需要提供依赖的动态库

# Makefile

## Makefile是什么？

* 工程中的源文件不计其数，按照类型，功能，模块分别放置在不同目录中。Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就像一个 she11 脚本一样，也可以执行操作系统的命令

* Makefile 带来的好处就是“自动化编译”。一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令比如 Delphi的 make，Visual C++ 的 nmake，Linux下GNU的 make。

## Makefile文件命名和规则

* 文件命名 ： makefile / Makefile

* Makefile规则：

一个Makefile文件中可以有一个或者多个**规则**，格式如下：

目标 ...: 依赖 ...
    命令（shell命令）
    ...

* 目标：最终要生成的文件（伪目标除外）
* 依赖：生成目标所需要的文件
* 命令：通过执行命令对依赖操作生成目标（命令前必须Tab缩进）

* Makefile中的其他规则一般都是为第一条规则服务的

## Makefile工作原理

* 命令在执行之前，需要先检查规则中的依赖是否存在
    如果存在，执行命令
    如果不存在，向下检查其他规则是否可以生成此依赖，如果找到了，则执行该规则中的命令

* 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间。（增量编译）
    如果以来的时间比目标的时间晚，需要重新生成目标
    如果以来的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行

## 变量

* 自定义变量：
    变量名=变量值   `var=hello`

* 预定义变量（已经提前定义好的变量）：
    `AR` : 归档维护程序的名称，默认值为 `ar`
    `CC` : C编译器的名称，默认值为 `cc`
    `CXX` : C++编译器的名称，默认值为 `g++`
    `@` : 目标的完整名称
    `<` : 第一个依赖文件的名称
    `^` : 所有的依赖文件

* 获取变量的值：
    $(变量名)

预定义变量的作用：

    例如：
    app:main.c a.c b.c
        gcc -c main.c a.c b.c

    使用预定义变量可以简化为：
    app:main.c a.c b.c
        $(CC) -c $^ -o $@

## 模式匹配

优化以下代码：
    add.o:add.c
        gcc -c add.c

    sub.o:sub.c
        gcc -c sub.c
        
    mult.o:mult.c
        gcc -c mult.c

    div.o:div.c
        gcc -c div.c

    main.o:main.c
        gcc -c main.c

`%.o:%.c` :
    `%` : 通配符，匹配一个字符串
    两个`%`匹配的是同一个字符串

`%.o:%.c` :
    gcc -c $< -o $@

## 函数


* wildcard函数 ：
    `$(wildcard PATTERN...)`
    功能：获取指定目录下指定类型的文件列表
    参数：`PATTERN`指的是某个或者多个目录下对应的某种类型的文件，如果有多个目录，一般使用空格间隔。
    返回：得到的若干个文件的文件列表，文件名之间使用空格间隔
    示例：
        $(wildcard *.c ./sub/*.c)
        返回值格式：a.c b.c c.c d.c e.c f.c ...
    
* patsubst函数：
    `$(patsubst <pattern>,<replacement>,<text>)`
    功能：查找`<text>`中的单词（单词以"空格"，"Tab"或者"回车"，"换行"分隔）是否符合模式`<pattern>`，如果匹配的话，则以`<replacement>`进行替换。`<pattern>`可以包括通配符`%`，表示任意长度的字符串。如果`<replacement>`中也包含`%`，那么，二者的`%`所代表的字符串内容一致。（可以使用`\%`来表示真实含义的`%`）
    返回：函数返回被替代后的字符串。
    示例：
        $(patsubst %.c, %.o, x.c bar.c)
        返回值格式：x.o bar.o

## 伪目标

为了删除生成的`.o`文件，可以在Makefile中加入一个clean目标，不添加任何依赖。在执行命令make的后面跟上目标参数，即可执行删除操作。（如果执行make命令而不添加目标参数，make只会执行第一个目标。）
例子：
    clean:
        rm $(objs) -f

    执行：make clean

然而，让我们在同级目录下存在一个与clean目标同名的文件时，由于makefile只会执行最新的文件，所以执行make clean命令时会提示目标已是最新而无法执行。事实上，我们根本不需要生成clean目标，因此只需设置一个伪目标即可。
例子：
    .PHONY:clean
    clean:
        rm -f $(objs) $(target) # 删除.o文件和可执行文件
    



