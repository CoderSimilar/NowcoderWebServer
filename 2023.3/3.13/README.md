# 信号
* 信号是Linux进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时会称之为“软件中断”，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。硬中断是指硬件中断。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
* 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：
  * 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号，比如输入`Ctrl+C`通常会给进程发送一个中断信号。
  * 硬件发生异常，即硬件检测到一个错误条件并通知内核，随机再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被0除，或者引用了无法访问的内存区域。
  * 系统状态变化，比如`alarm`定时器到期将引起`SIGALRM`信号，进程执行的CPU时间超限，或者该进程的某个子进程退出。
  * 运行`kill`命令或者`kill`函数。

## 使用信号的两个主要目的
* 让进程直到已经发生了一件特定的事情。
* 强迫进程执行他自己代码中的信号处理程序

## 信号的特点
* 简单
* 不能携带大量信息
* 满足某个特定条件才发送 
* 优先级比较高

* 查看系统定义的信号列表：`kill -l`

* 前31个信号为常规信号，其余为实时信号。

## Linux信号一览

| 编号 | 信号名 | 对应事件 | 默认动作 |
| :-: | :-: | :-: | :-: |
| 1 | SIGHUP | 用户退出shell时，由该shell启动的所有进程将收到这个信号 | 终止进程 |
| 2 | **SIGINT** | 当用户按下 <ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号 | 终止进程 |
| 3 | **SIGQUIT** | 用户按下<ctr1+\\>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号 | 终止进程 |
| 4 | SIGILL | CPU检测到某进程执行了非法指令 | 终止进程并产生core文件 |
| 5 | SIGTRAP | 该信号由断点指令或其他 trap指令产生 | 终止进程并产生core文件 |
| 6 | SIGABRT | 调用abort函数时产生该信号 | 终止进程并产生core文件 |
| 7 | SIGBUS | 非法访问内存地址，包括内存对齐出错 | 终止进程并产生core文件 |
| 8 | SIGFPE | 在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误 | 终止进程并产生core文件 |
| 9 | SIGKILL | 无条件终止进程，该信号不能被忽略、处理和阻塞 | 终止进程，可以杀死任何进程 |
| 11 | SIGSEGV | 指示内存进行了无效内存访问（段错误） | 终止进程并产生core文件 |
| 13 | SIGPIPE | Broken pipe向一个没有读端的管道写数据 | 终止进程 |
| 17 | SIGCHLD | 子进程结束时，父进程会收到这个信号 | 忽略这个信号 |
| 18 | SIGCONT | 如果进程已经停止，则使其继续运行 | 继续/忽略 |
| 19 | SIGSTOP | 停止进程的执行，信号不能被忽略、处理和阻塞 | 终止进程 |

## 信号的5种默认处理动作
* 查看信号的详细信息：man 7 signal
* 信号的5种默认处理动作
  * Term    终止进程
  * Ign     当前进程忽略掉这个信号
  * Core    终止进程，并生成一个Core文件
  * Stop    暂停当前进程
  * Cont    继续执行当前被暂停的进程

* 信号的几种状态：产生、未决、递达
* SIGKILL 和 SIGSTOP信号不能被捕捉、阻塞或者忽略，只能执行默认动作。
