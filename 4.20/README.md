# 线程同步
* 共享信息线程的主要优势在于：能够通过全局变量来，不过，这种便捷的共享是有代价的:必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。
* **临界区**是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。
* 线程同步:即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。
# 互斥量
* 为避免线程更新共享变量时出现问题，可以使用互斥量 (mutex 是 mutual exclusion的缩写)来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。
* 互斥量有两种状态:已锁定 (locked) 和未锁定 (unlocked)。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。
* 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源 (可能由多个相关变量组成)会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议:
  * 针对共享资源锁定互斥量
  * 访问共享资源
  * 对互斥量解锁

* 如果多个线程试图执行这一块代码(一个临界区)，事实上只有一个线程能够持有该互斥量(其他线程将遭到阻塞)，即同时只有一个线程能够进入这段代码区域。

## 互斥量相关操作函数
互斥量的类型： pthread_mutex_t
* int pthread mutex init(pthread mutex t *restrict mutex,const pthread mutexattr t *restrict attr);
* int pthread mutex destroy(pthread mutex t *mutex);
* int pthread mutex lock(pthread mutex t *mutex);
* int pthread mutex trylock(pthread mutex t *mutex);
* int pthread mutex unlock(pthread mutex t *mutex);

# 死锁

* 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。
* 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象。若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。
* 死锁的几种场景:
  * 忘记释放锁
  * 重复加锁
  * 多线程多锁，抢占锁资源



