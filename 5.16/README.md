# epoll的工作模式

* LT模式（水平触发）
  * 假设委托内核检测读事件 -> 检测fd的读缓冲区
    * 读缓冲区有数据 -> epoll检测到了会给用户通知
      * a.用户不读数据，数据一直在缓冲区，epoll会一直通知
      * b.用户只读了一部分数据，epoll会通知
      * c.缓冲区的数据读完了，不通知
    > LT(Level-Triggered)是默认的工作方式，并且同时支持block和no-block socket。在这种做法中，北河告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行I/O操作。如果你不做任何操作，内核还是会继续通知你的。
* ET模式（边沿触发）
  * 假设委托内核检测读事件 -> 检测fd的读缓冲区
    * 读缓冲区有数据 -> epoll检测到了会给用户通知
      * a.用户不读数据，数据一直在缓冲区，epoll下次检测到的时候就不通知了
      * b.用户只读了一部分数据，epoll不会通知
      * c.缓冲区的数据读完了，不通知
    > ET(Edge-Triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）
    > ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

```
struct epoll_event {
    uint32_t        events; //epoll events
    epoll_data_t    data;   //user data variable
};

常见的Epoll检测事件：
    - EPOLLIN
    - EPOLLOUT
    - EPOLLERR
    - EPOLLET
```


