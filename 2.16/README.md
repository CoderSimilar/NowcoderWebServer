# 动态库的制作和使用

## 命名规则：

* Linux：**libxxx.so**
    lib : 前缀（固定）
    xxx : 库名（自己起）
    .so : 后缀（固定）
**动态库在Linux下是一个可执行文件**

* Windows：**libxxx.dll**

## 动态库制作：

* `gcc`得到`.o`文件，得到和位置无关的代码。（加参数`-fPIC`）
    `gcc -c -fpic/-fPIC *.c`

* `gcc`得到动态库
    `gcc -shared *.o -o libxxx.so`

**这样制作的动态库不能使用，因为在程序运行时动态库没有加载到内存中**

## 工作原理

* 静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中
* 动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中

* 程序启动之后，动态库会被动态加载到内存中，通过`ldd`(list ayname dependencies)命令可以检查动态库的依赖关系

**如何定位共享库文件？**

当系统加载可执行代码的时候，能够知道其所依赖库的名字，但是还需要知道绝对路径。
此时就需要系统的**动态载入器**来获取该绝对路径。对于`elf`格式的可执行程序，是由`ld-linux.so`来完成的
它先后搜索elf文件的 **DT_RPATH段** ——> **环境变量LD_LIBRARY_PATH** ——> **/etc/ld.so.cache文件列表** ——> **/lib/,/usr/lib** 目录找到库文件后将其载入内存。

### 修改环境变量

`env`查看环境变量，环境变量通常以键值对的方式出现。

使用`export 环境变量=$环境变量:动态库地址` 可以修改环境变量，`$`表示获取原环境变量的值，`:`代表在原环境变量值的后面添加内容。
例如：`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/admin/cppCode/2.16/library`
**在命令行输入这条命令，则修改环境变量的操作只在当前终端生效；**

## 用户级别修改环境变量：

要在**用户级别**修改环境变量，需要进入家目录`cd ~`,输入`ll`即可看到`.bashrc`文件。使用vim将其打开，`shift+g`定位至最后一行。添加`export 环境变量=$环境变量:动态库地址`,保存退出。并使用`. .bashrc`或者`source .bashrc`命令进行刷新即可。

## 系统级别配置环境变量：

要在**系统级别**配置环境变量，需要使用`sudo vim /etc/profile`进入系统文件，然后添加`export 环境变量=$环境变量:动态库地址`到最后一行，保存退出并使用`. /etc/profile`或者`source /etc/profile`刷新即可

## 修改/etc/ld.so.cache文件

/etc/ld.so.cache中是二进制文件，不能使用vim进行编辑，但是可以通过`sudo vim /etc/ld.so.conf`命令打开`/etc/ld.so.conf` 文件，在里面添加**动态库路径**，保存退出后输入`sudo ldconfig`进行更新即可。

## 将动态库放置在`/lib`目录下

不建议使用这种方式，因为`/lib`，`usr/lib`目录下存在其他文件，容易误操作。

# 静态库和动态库的对比

**静态库优缺点**

* 优点：
    静态库被打包到应用程序中加载速度快
    发布程序无需提供静态库，移植方便

* 缺点：
    消耗系统资源
    更新、部署、发布麻烦

**动态库优缺点：**

* 优点：
    可以实现进程间资源共享（共享库）
    更新、部署、发布简单
    可以控制何时加载动态库

* 缺点：
    加载速度比静态库慢
    发布程序时需要提供依赖的动态库



