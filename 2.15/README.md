# GCC详解

* 源代码（.h/.c/.cpp） --> 预处理 --> 预处理后源代码（.i）

    预处理阶段：

    ​	展开头文件

    ​	删除注释

    ​	展开宏

* 预处理后源代码（.i） -->  编译器 --> 汇编代码（.s）

* 汇编代码（.s） -->  汇编器 --> 目标代码（.o）

**目标代码即为计算机能够理解的机器指令。**


* 链接：目标代码 + 启动代码 + 库代码（静态库，动态库）+ 其他目标代码 --> 链接器  --> 可执行程序（Windows下为.exe， Linux下为.out）



gcc 编译选项：
    -E : 预处理指定的源文件，不进行编译（.h/.c/.cpp --> .i）
    -s : 编译指定的源文件，但是不进行汇编（.i --> .s）
    -c : 编译、汇编指定的源文件，但是不进行链接（.s --> .o）
    -o [file1] [file2] / [file2] -o [file1] : 将文件file2编译成可执行文件file1
    -I directory :指定include包含文件的搜索目录
    -g : 编译的时候生成调试信息，该程序可以被调试器调试
    -D : 程序编译的时候指定一个宏 (方便调试程序)
    -w : 不生成任何警告信息
    -Wall: 生成所有的警告
    -On : n的取值范围：0~3，表示编译器优化选项的4个级别，-o0表示没有任何优化，-o1是默认值，-o3表示优化级别最高
    -l : 程序编译的时候使用指定的库 (制作动态库时会用到)
    -L : 指定编译的时候，搜索库的路径（制作动态库时会用到）
    -fpic/FPIC : 生成与位置无关的代码 （制作动态库时会用到）
    -shard : 生成共享目标文件，通常用在建立共享库的时候
    -std : 指定C方言，如：-std=c99，gcc默认的方言是GNU C

gcc编译C代码，g++编译C++,也能编译C

### 误区一：gcc只能编译C代码，g++只能编译C++代码
*   后缀为 `.c` 的，gcc会把它当作是**C**程序，而g++当作是**C++**程序
*   后缀为 `.cpp`的，两者都会认为是C++程序，C++的语法规则更加严谨。
*   编译阶段，g++回调用gcc,对于C++代码，两者是等价的，但是由于gcc命令不能自动和C++程序使用的库相链接，
    所以通常用g++来完成链接。为了统一，干脆编译/链接都使用g++了。

### 误区二：gcc不会定义__cpluscplus宏，而g++会
*   实际上，这个宏只是标志着编译器将会把代码按照C还是C++语法来解释
*   如果后缀为 `.c`，并且采用gcc编译器，那么该宏就是未定义的，否则就是已经定义。

### 误区三：编译只能用gcc，链接只能用g++
*   应该是：编译可以用gcc/g++,而链接可以使用g++或者gcc -lstdc++
*   gcc命令不能够自动和C++程序使用的库相链接，所以通常使用g++来完成链接。但是在编译阶段，g++会自动调用gcc，二者等价。

# 库的制作和使用

## 什么是库：

* 库文件是计算机上的一类文件，可以简单将其看作一种代码仓库，提供给使用者一些可以直接拿来用的变量，函数或者类
* 库是一种特殊的程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行
* 库文件有两种：静态库和动态库（共享库）。两者的区别是：静态库在程序的链接阶段被复制到了程序中；
  动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。
* 库的好处：1，代码保密；2，方便部署和分发

**对于C/C++语言，反编译工具的还原度很低。**

## 静态库的制作：

### 静态库命名规则：
* Linux：libxxx.a
    lib : 前缀（固定）
    xxx : 库的名字，自己起
    .a : 后缀（固定）

### 静态库制作：
* 1，`gcc -c xxx.c` 获得 `.o` 文件；
* 2，将`.o`文件打包，使用`ar`工具（archive）
    `ar rcs libxxx.a xxx.o xxx.o`
    参数解释：r - 将文件插入备存文件中
             c - 建立备存文件
             s - 索引

* 实际项目开发时，通常有以下几个目录：
    * include目录：用于存放函数的声明以及头文件等；
    * lib目录：用于存放动态库，静态库等库文件；
    * src目录：用于存放函数的具体实现源码；
    * main函数：测试代码
### 静态库使用：

当使用`ar rcs libxxx.a *.o`命令制作好静态库文件以后，可以使用`gcc main.c -o testname -I ./include -l xxx -L lib/`来编译测试代码并运行。
其中，`-o`参数表示将测试源码编译成可执行目标文件，`-I`代表去指定的路径搜索include文件并将其包含；`-l`参数后跟静态库名（注意并非静态库文件名，静态库文件名指的是libxxx.a；静态库名指的是xxx）；`-L`后跟静态库的存放路径。
    

